<?php

namespace App\Models;

use App\Enums\MomentCouponGroup;
use App\Enums\SocialPlatform;
use App\Enums\StateOrder;
use App\Enums\StatePresetProduct;
use App\Enums\StateQna;
use App\Enums\StateReport;
use App\Enums\TypeCouponGroup;
use App\Enums\TypePointHistory;
use App\Models\임시\Product;
use Carbon\Carbon;
use Illuminate\Database\Eloquent\Builder;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\SoftDeletes;
use Illuminate\Foundation\Auth\User as Authenticatable;
use Illuminate\Notifications\Notifiable;
use Laravel\Sanctum\HasApiTokens;
use Spatie\MediaLibrary\HasMedia;
use Spatie\MediaLibrary\InteractsWithMedia;
use Tymon\JWTAuth\Contracts\JWTSubject;

class User extends Authenticatable implements HasMedia, JWTSubject
{
    use HasApiTokens, HasFactory, Notifiable, InteractsWithMedia;

    use SoftDeletes;

    protected $guarded = ["id"];

    /**
     * Get the identifier that will be stored in the subject claim of the JWT.
     *
     * @return mixed
     */
    public function getJWTIdentifier()
    {
        return $this->getKey();
    }

    /**
     * Return a key-value array, containing any custom claims to be added to the JWT.
     *
     * @return array
     */
    public function getJWTCustomClaims()
    {
        return [];
    }

    /**
     * The attributes that should be hidden for serialization.
     *
     * @var array
     */
    protected $hidden = [
        'password',
        'remember_token',
    ];

    /**
     * The attributes that should be cast.
     *
     * @var array
     */
    protected $casts = [
        'email_verified_at' => 'datetime',
    ];

    protected $appends = ["img"];

    public static $recommendPoint = 2000; // 추천 포인트

    protected $nicknames = [
        "감자", "고구마", "양파", "마늘", "생강", "당근", "무", "배추", "상추",
        "시금치", "브로콜리", "토마토", "오이", "호박", "가지", "고추", "피망", "파프리카",
        "부추", "대파", "청경채", "샐러리", "케일", "로메인", "치커리", "도토리", "홍시", "단감", "파파야",
        "미나리", "깻잎", "비트", "옥수수", "바질", "고수", "딜", "타임", "민트", "루꼴라", "무화과",
        "배", "사과", "감", "포도", "복숭아", "자두", "딸기", "블루베리", "체리", "키위", "바나나",
        "파인애플", "망고", "레몬", "라임", "자몽", "오렌지", "참외", "수박", "멜론", "석류", "밤", "호두",
        "아몬드", "땅콩", "버섯", "더덕", "연근", "우엉", "콜라비", "유자", "감귤", "한라봉", "민들레", "곶감", "매실", "보리", "카카오"
    ];

    protected static function boot()
    {
        parent::boot(); // TODO: Change the autogenerated stub

        self::creating(function ($model){
            $grade = Grade::orderBy('level', 'asc')->first();
            $model->grade_id = $grade ? $grade->id : null;
            $model->code = $model->nicknames[rand(0, count($model->nicknames) - 1)].Generator::createUuid($model, 6, 'code');
            $model->nickname = $model->nicknames[rand(0, count($model->nicknames) - 1)].$model->code;
        });

        self::created(function ($model){
            $model->cart()->create();

            if($model->grade){
                $couponGroup = CouponGroup::where('grade_id', $model->grade->id)->where('moment', MomentCouponGroup::GRADE)->first();

                if($couponGroup){
                    Coupon::create([
                        'user_id' => $model->id,
                        'coupon_group_id' => $couponGroup->id,
                    ]);
                }
            }
        });

        self::updated(function ($model){
            $prevGradeId = $model->getOriginal('grade_id');

            if($prevGradeId != $model->grade_id){
                $grade = Grade::find($model->grade_id);

                if($grade){
                    $couponGroup = CouponGroup::where('grade_id', $grade->id)->where('moment', MomentCouponGroup::GRADE)->first();

                    if($couponGroup){
                        Coupon::create([
                            'user_id' => $model->id,
                            'coupon_group_id' => $couponGroup->id,
                        ]);
                    }
                }
            }
            $couponGroup = CouponGroup::where('moment', MomentCouponGroup::UPDATE_PROFILE)->first();

            if($couponGroup){
                $coupon = Coupon::where('user_id', $model->id)->where('coupon_group_id', $couponGroup->id)->first();

                if($model->birth && $model->count_family && !$coupon)
                    Coupon::create([
                        'user_id' => $model->id,
                        'coupon_group_id' => $couponGroup->id
                    ]);
            }
        });

        self::deleting(function ($model){

        });

        self::deleted(function ($model){

        });
    }

    public function registerMediaCollections():void
    {
        $this->addMediaCollection('img')->singleFile();
    }

    public function getImgAttribute()
    {
        if($this->hasMedia('img')) {
            $media = $this->getMedia('img')[0];

            return [
                "id" => $media->id,
                "name" => $media->file_name,
                "url" => $media->getFullUrl()
            ];
        }

        return null;
    }

    public function reports()
    {
        return $this->hasMany(Report::class);
    }

    public function grade()
    {
        return $this->belongsTo(Grade::class);
    }

    public function cart()
    {
        return $this->hasOne(Cart::class);
    }

    public function socials()
    {
        return $this->hasMany(Social::class);
    }

    public function products()
    {
        return $this->hasMany(Product::class);
    }

    public function orders()
    {
        return $this->hasMany(Order::class);
    }

    public function refunds()
    {
        return $this->hasMany(Refund::class);
    }

    public function getSocialAttribute()
    {
        if($this->social_platform == "google")
            return SocialPlatform::GOOGLE;

        if($this->social_platform == "apple")
            return SocialPlatform::APPLE;

        if($this->social_platform == "kakaoCustom")
            return SocialPlatform::KAKAO;

        if($this->social_platform == "naverCustom")
            return SocialPlatform::NAVER;

        return "";
    }

    public function qnas()
    {
        return $this->hasMany(Qna::class);
    }

    public function coupons()
    {
        return $this->hasMany(Coupon::class);
    }

    public function canUseCoupons($presetProduct = null)
    {
        $items = $this->coupons()->where('use', 0)
            ->whereHas('couponGroup', function ($query) use ($presetProduct) {
                $query->where(function ($query) use ($presetProduct) {
                    $query->whereIn('type', [TypeCouponGroup::ALL, TypeCouponGroup::DELIVERY])
                        ->orWhere(function ($query) use ($presetProduct){
                            $query->where('type', TypeCouponGroup::PRODUCT)
                                ->where(function ($query) use($presetProduct){
                                    $query->where('all_product', 1)
                                        ->orWhereHas('products', function ($query) use ($presetProduct) {
                                            $query->where('products.id', $presetProduct->product_id);
                                        });
                                });
                        });
                })->where('min_price_order', '<=', $presetProduct->products_price)
                    ->where('started_at', '<=', Carbon::now())
                    ->where('finished_at', '>=', Carbon::now());
            });

        return $items;
    }

    public function validCoupons()
    {
        return $this->coupons()
            ->where(function ($query){
               /* $query->where('order_id', null)
                    ->orWhereHas('order', function ($query){
                        $query->whereIn('state', [StateOrder::BEFORE_PAYMENT, StateOrder::CANCEL]);
                    });*/
            })
            ->where('will_finished_at', '>=', Carbon::now()->startOfDay());
    }

    public function getCountValidCouponAttribute()
    {
        return $this->validCoupons()->count();
    }

    public function getCountAlarmAttribute()
    {
        return $this->alarms()->where('read', 0)->count();
    }

    public function getCountCouponAttribute()
    {
        return $this->coupons()->where('use', 0)->count();
    }

    public function getCountTotalCouponAttribute()
    {
        return $this->coupons()->count();
    }

    public function getCountPackageAttribute()
    {
        return $this->presetProducts()->whereNotNull('package_id')
            ->where('state', '!=', StatePresetProduct::BEFORE_PAYMENT)
            ->count();
    }

    public function getCountProductAttribute()
    {
        return $this->presetProducts()->whereNotNull('product_id')
            ->where('state', '!=', StatePresetProduct::BEFORE_PAYMENT)
            ->count();
    }

    public function presets()
    {
        return $this->hasMany(Preset::class);
    }

    public function presetProducts()
    {
        return $this->hasManyThrough(PresetProduct::class, Preset::class);
    }

    public function ongoingPresetProducts()
    {
        return $this->presetProducts()
            ->whereIn('state', [
                StatePresetProduct::WAIT,
                StatePresetProduct::READY,
                StatePresetProduct::ONGOING_DELIVERY
            ]);
    }

    public function ongoingPackagePresetProducts()
    {
        return $this->presetProducts()
            ->whereIn('state', [
                StatePresetProduct::BEFORE_PAYMENT,
                StatePresetProduct::READY,
                StatePresetProduct::WAIT,
                StatePresetProduct::READY,
                StatePresetProduct::ONGOING_DELIVERY
            ])->orWhere(function (Builder $query) {
                $query->where('state', StatePresetProduct::DELIVERED)
                    ->where('package_will_delivery_at', '>=', Carbon::now()->subDay()->startOfDay());
        });
    }

    public function getCountOngoingPresetProductAttribute()
    {
        return $this->ongoingPresetProducts()->count();
    }

    public function getFormatOngoingPresetProductsAttribute()
    {
        $ongoingPresetProducts = $this->ongoingPresetProducts;

        $result = "";

        if(count($ongoingPresetProducts) > 1)
            return $ongoingPresetProducts->first()->product_title." 외 " .($ongoingPresetProducts->count() - 1)."건";

        return $ongoingPresetProducts->count() > 0 ? $ongoingPresetProducts->first()->product_title : "";
    }

    public function reviews()
    {
        return $this->hasMany(Review::class);
    }

    public function deliveries()
    {
        return $this->hasMany(Delivery::class);
    }

    public function pointHistories()
    {
        return $this->hasMany(PointHistory::class);
    }

    public function getPointUseAttribute()
    {
        return $this->pointHistories()->where('increase', 0)->sum('point_histories.point');
    }

    public function getPointAttribute()
    {
        return $this->points()->sum('point');
    }

    public function packageSetting()
    {
        return $this->hasOne(PackageSetting::class);
    }

    public function couponHistories()
    {
        return $this->hasMany(CouponHistory::class);
    }

    public function likes()
    {
        return $this->hasMany(Like::class);
    }

    public function bookmarks()
    {
        return $this->hasMany(Bookmark::class);
    }

    public function cards()
    {
        return $this->hasMany(Card::class);
    }

    public function vegetableStories()
    {
        return $this->hasMany(VegetableStory::class);
    }

    public function comments()
    {
        return $this->hasMany(Comment::class);
    }

    public function points()
    {
        return $this->hasMany(Point::class);
    }

    public function givePoint($point, $type, $relationModel = null, $memo = null)
    {
        $pointModel = $this->points()->create([
            'point' => $point
        ]);

        PointHistory::create([
            'point_id' => $pointModel->id,
            'type' => $type,
            'increase' => 1,
            'point' => $point,
            'point_leave' => $this->point,
            'point_historiable_type' => $relationModel ? get_class($relationModel) : null,
            'point_historiable_id' => $relationModel ? $relationModel->id : null,
            'user_id' => $this->id,
            'memo' => $memo,
        ]);
    }

    public function takePoint($point, $type, $relationModel = null, $pointModel = null, $memo = null)
    {
        return \DB::transaction(function () use ($point, $type, $relationModel, $pointModel) {
            // 특정 포인트에서만 차감하고싶을 때
            if ($pointModel) {
                $pointModel->update([
                    'point' => $pointModel->point - $point
                ]);

                return PointHistory::create([
                    'type' => $type,
                    'increase' => 0,
                    'point' => $point,
                    'point_leave' => $this->point,
                    'point_historiable_type' => $relationModel ? get_class($relationModel) : null,
                    'point_historiable_id' => $relationModel ? $relationModel->id : null,
                    'user_id' => $this->id,
                ]);
            }

            // 여러 포인트에서 차감
            $pointModels = $this->points()->oldest()->where('point', '>', 0)->cursor();
            $pointTakeTotal = 0;

            foreach ($pointModels as $pointModel) {
                if ($point <= 0)
                    break;

                $pointTake = min($pointModel->point, $point);
                $pointTakeTotal += $pointTake;
                $point -= $pointTake;

                $pointModel->update(['point' => $pointModel->point - $pointTake]);
            }

            // 히스토리 기록
            return PointHistory::create([
                'type' => $type,
                'increase' => 0,
                'point' => $pointTakeTotal,
                'point_leave' => $this->point,
                'point_historiable_type' => $relationModel ? get_class($relationModel) : null,
                'point_historiable_id' => $relationModel ? $relationModel->id : null,
                'user_id' => $this->id,
            ]);
        });
    }

    public function getCountPackageForNextGradeAttribute()
    {
        $grade = $this->grade;

        if(!$grade)
            return 0;

        $nextGrade = Grade::where('level', $grade->level + 1)->first();

        if(!$nextGrade)
            return 0;

        return $nextGrade->min_count_package - $this->total_order_count_package;
    }

    public function getPriceForNextGradeAttribute()
    {
        $grade = $this->grade;

        if(!$grade)
            return 0;

        $nextGrade = Grade::where('level', $grade->level + 1)->first();

        if(!$nextGrade)
            return 0;

        return $nextGrade->min_price - $this->total_order_price;
    }

    public function getCurrentPackagePresetProduct()
    {
        $ongoingPackage = Package::getOngoing();

        // 출고의 대상회차가 현재 진행중인 회차라면
        if($ongoingPackage){
            $presetProduct = $this->presetProducts()->where('package_id', $ongoingPackage->id)->first();

            if($presetProduct)
                return $presetProduct;
        }

        // 패키지설정의 구독여부가 꺼져있다면 (active 0) null을 리턴
        // 가장 최근애를 가져오면 되지않나? 싶지만 과거 구매이력 있을 경우 계속 걔가 떠있을거임, 근데 마이페이지에서는 이미 지난건만 있고 비활성 상태면 다시 구독하라고 권장하는 ui 필요
        $packageSetting = $this->packageSetting;

        if(!$packageSetting || !$packageSetting->active)
            return null;

        // 가장 최근 꾸러미 출고 리턴
        return $this->presetProducts()->orderBy('id', 'desc')->whereHas('package')->first();
    }

    public function getCountRecommendedAttribute()
    {
        return User::where('code_recommend', $this->code)->count();
    }

    public function getCountReportAttribute()
    {
        return $this->reports()->count();
    }
    public function getCountFinishReportAttribute()
    {
        return $this->reports()->whereIn('state', [StateReport::FINISH, StateReport::HIDE])->count();
    }

    public function getCountQnaAttribute()
    {
        return $this->qnas()->count();
    }

    public function getCountAnswerQnaAttribute()
    {
        return $this->qnas()->where('state', StateQna::FINISH)->count();
    }

    public function stopHistories()
    {
        return $this->hasMany(StopHistory::class);
    }
}
