<?php

namespace App\Models;

use App\Enums\MomentCouponGroup;
use App\Enums\StateOrder;
use App\Enums\StatePresetProduct;
use App\Enums\TypeAlarm;
use App\Enums\TypeCouponHistory;
use App\Enums\TypeOption;
use App\Enums\TypePointHistory;
use App\Mail\PrototypeNeeded;
use Carbon\Carbon;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Support\Facades\DB;
use Illuminate\Support\Facades\Mail;

class Order extends Model
{
    use HasFactory;

    protected $guarded = ['id'];

    public static $minPrice = 1000;

    protected static function boot()
    {
        parent::boot(); // TODO: Change the autogenerated stub

        self::updating(function ($model){
            $prevState = $model->getOriginal('state');

            if($prevState != StateOrder::WAIT && $model->state == StateOrder::WAIT) {
                if(!$model->process_record)
                    $model->record();

                $model->process_record = true;
            }

            if($prevState != StateOrder::CANCEL && $model->state == StateOrder::CANCEL)
                $model->rollback();

            if($prevState != StateOrder::SUCCESS && $model->state == StateOrder::SUCCESS) {
                if($prevState != StateOrder::WAIT) {
                    if(!$model->process_record)
                        $model->record();

                    $model->process_record = true;
                }

                // $accessToken = Iamport::getAccessToken();
                // $model->check_receipt = Iamport::checkReceipt($accessToken, $model->imp_uid);

                $model->success();
                $model->process_success = true;
                $model->success_at = Carbon::now();

                /*Alarm::create([
                    'contact' => $model->buyer_contact,
                    'order_id' => $model->id,
                    'type' => TypeAlarm::ORDER_SUCCESS,
                ]);*/
            }
        });

        self::updated(function ($model){
            $prevState = $model->getOriginal('state');

            if($prevState != StateOrder::WAIT && $model->state == StateOrder::WAIT) {
                if($model->pay_method_method == "vbank")
                    Alarm::create([
                        'contact' => $model->buyer_contact,
                        'order_id' => $model->id,
                        'type' => TypeAlarm::ORDER_CREATED_BY_VBANK,
                    ]);
            }

        });
    }

    public function createFirstOrderCoupon()
    {
        $couponGroup = CouponGroup::where('moment', MomentCouponGroup::FIRST_ORDER)->first();

        if($couponGroup){
            $coupon = Coupon::where('user_id', $this->user_id)->where('coupon_group_id', $couponGroup->id)->first();

            if(!$coupon){
                Coupon::create([
                    'user_id' => $this->user_id,
                    'coupon_group_id' => $couponGroup->id,
                ]);
            }
        }

    }

    // 포인트내역, 쿠폰내역 기록, 장바구니 삭제
    public function record()
    {
        if(!$this->process_record) {
            // 첫구매 쿠폰 발급
            $user = User::withTrashed()->find($this->user_id);

            $this->createFirstOrderCoupon();

            if($this->point_use)
                $user->takePoint($this->point_use, TypePointHistory::ORDER_CREATED, $this);

            /*$coupon = $this->coupon;

            if ($coupon) {
                $user->couponHistories()->create([
                    'title' => $coupon->title,
                    'type' => TypeCouponHistory::ORDER_CREATED,
                    'increase' => 0,
                ]);
            }*/

            // 장바구니에서 삭제
            $this->presets()->update([
                'cart_id' => null,
            ]);
        }
    }

    // 포인트내역, 쿠폰내역 롤백
    public function rollback()
    {
        $user = User::withTrashed()->find($this->user_id);

        if($user) {
            if($this->point_use){
                $user->update(['point' => $user->point + $this->point_use]);

                $user->pointHistories()->create([
                    'point_current' => $user->point,
                    'point' => $this->point_use,
                    'type' => TypePointHistory::PRESET_PRODUCT_CANCLE,
                    'increase'=>1,
                ]);
            }


            $coupon = $this->coupon;

            if($coupon){
                $user->couponHistories()->create([
                    'title' => $coupon->title,
                    'type' => TypeCouponHistory::ORDER_CANCLED,
                    'increase'=>1,
                ]);
            }
        }
    }

    // 상품준비중 처리
    public function success()
    {
        if(!$this->process_success){
            // 출고정리
            $this->presetProducts()->update([
                'state' => StatePresetProduct::READY,
            ]);

            $presets = $this->presets()->cursor();

            foreach($presets as $preset){
                $products = $preset->products()->cursor();

                foreach($products as $product){
                    $product->update(['count_order' => $product->count_order + 1]);
                }
            }
        }

    }

    public function getFormatStateAttribute()
    {
        return StateOrder::getLabel($this->state);
    }

    public function ready($presetItems, $user = null, $guestId = null)
    {
        $presets = collect();

        foreach($presetItems as $presetItem){
            $preset = Preset::find($presetItem['id']);

            if($user && $preset->user_id != $user->id)
                return [
                    'success' => false,
                    'message' => '자신의 상품만 구매할 수 있습니다'
                ];

            if(!$user && $preset->guest_id != $guestId)
                return [
                    'success' => false,
                    'message' => '자신의 상품만 구매할 수 있습니다'
                ];

            if(!$preset->can_order)
                return [
                    'success' => false,
                    'message' => '구매할 수 없는 상품이 포함되어있습니다.'
                ];

            $presets->add($preset);
        }

        $order = Order::create([
            'user_id' => $user ? $user->id : null,
            'user_contact' => $user ? $user->contact : "",
            'user_email' => $user ? $user->email : "",
            'user_name' => $user ? $user->name : "",
            'guest_id' => $guestId,

            'state' => StateOrder::BEFORE_PAYMENT,
        ]);

        foreach($presets as $preset){
            $preset->update([
                'order_id' => $order->id,
            ]);
        }

        return [
            'success' => true,
            'data' => $order
        ];
    }

    // 맞춤결제여부
    public function isCustomOrder()
    {
        $countTotal = $this->presetProducts()->whereHas('product', function ($query){
            $query->whereNull('product_id'); // 추가상품은 제외
        })->count();

        $countCustom = $this->presetProducts()->whereHas('product', function ($query){
            $query->whereNull('product_id') // 추가상품은 제외
                ->where('custom', 1);
        })->count();

        if($countCustom > 0 && $countCustom == $countTotal)
            return true;

        return false;
    }

    public function attempt($data, $guestId = null)
    {
        $presets = $this->presets;

        $pricePresets = 0;
        $point = $data['point_use'];

        if($point > 0 && auth()->user()->point < $point)
            return [
                'success' => false,
                'message' => '보유 포인트가 부족합니다.'
            ];

        foreach($presets as $preset){

            if(!$preset->can_order)
                return [
                    'success' => false,
                    'message' => '주문할 수 없습니다. 관리자에게 문의해주세요.'
                ];

            $pricePresets += $preset->price;

            $preset->presetProducts()->update([
                'delivery_name' => $data['delivery_name'],
                'delivery_contact' => $data['delivery_contact'],
                'delivery_address' => $data['delivery_address'],
                'delivery_address_detail' => $data['delivery_address_detail'],
                'delivery_address_zipcode' => $data['delivery_address_zipcode'],
                'delivery_requirement' => isset($data['delivery_requirement']) ? $data['delivery_requirement'] : null,
            ]);
        }


        $price = $pricePresets - $point;

        if($price < self::$minPrice)
            return [
                'success' => false,
                'message' => '최소결제금액은 1,000원입니다.'
            ];

        $payMethod = PayMethod::find($data['pay_method_id']);

        $this->update([
            'price' => $price,
            'point_use' => $point,
            /*'price_products' => $priceProducts,
            'price_delivery' => $priceDelivery,
            'point_use' => $point,
            'price_coupon_discount' => $priceCouponDiscount,*/

            'merchant_uid' => 'ORD-' . $this->id.Carbon::now()->format('Hisv'),
            'pay_method_id' => $payMethod->id,
            'pay_method_pg' => $payMethod->pg,
            'pay_method_method' => $payMethod->method,
            'pay_method_name' => $payMethod->name,
            'pay_method_commission' => $payMethod->commission,

            'buyer_name' => auth()->user()->name ?? auth()->user()->nickname,
            'buyer_email' => auth()->user()->email,
            'buyer_contact' => $data['delivery_contact'],

            'delivery_name' => $data['delivery_name'],
            'delivery_contact' => $data['delivery_contact'],
            'delivery_address' => $data['delivery_address'],
            'delivery_address_detail' => $data['delivery_address_detail'],
            'delivery_address_zipcode' => $data['delivery_address_zipcode'],
            'delivery_requirement' => isset($data['delivery_requirement']) ? $data['delivery_requirement'] : null,
        ]);

        /*if($coupon)
            $coupon->update(['order_id' => $this->id]);*/

        return [
            'success' => true,
        ];
    }

    public function presets()
    {
        return $this->hasMany(Preset::class);
    }

    public function presetProducts()
    {
        return $this->hasManyThrough(PresetProduct::class, Preset::class);
    }

    public function checkCanOrderSaleProduct($saleProduct, $count)
    {
        if(!$saleProduct)
            return [
                'success' => false,
                'message' => '존재하지 않는 상품이 포함되어있습니다.'
            ];

        if($saleProduct->count < $count)
            return [
                'success' => false,
                'message' => '재고가 부족합니다.'
            ];

        /*if(!$saleProduct->open)
            return [
                'success' => false,
                'message' => '비공개 상품이 포함되어있습니다.'
            ];*/

        return [
            'success' => true,
        ];
    }



    public function getAdminCanCancelAttribute()
    {
        /*if(!auth()->user() || !auth()->user()->admin)
            return 0;

        if($this->pay_method_method == "vbank")
            return 0;

        if($this->presetProducts()->whereIn('state', [
                StatePresetProduct::CONFIRMED,
                StatePresetProduct::CANCEL
            ])->count() > 0) {
            return 0;
        }

        return 1;*/
    }

   /* public function coupon()
    {
        return $this->hasOne(Coupon::class);
    }*/

    public function getPriceProductsAttribute()
    {
        $total = 0;

        $presetProducts = $this->presetProducts()->cursor();

        foreach($presetProducts as $presetProduct){
            if($presetProduct->product_id){
                if($presetProduct->option_type == TypeOption::REQUIRED)
                    $total += $presetProduct->product_price + $presetProduct->option_price;

                if($presetProduct->option_type == TypeOption::ADDITIONAL)
                    $total += $presetProduct->option_price;
            }

            if($presetProduct->package_id){
                $materials = $presetProduct->materials;

                foreach($materials as $material){
                    $total += $material->pivot->price;
                }
            }
        }

        return $total;
    }

    public function getPriceOriginProductsAttribute()
    {
        $total = 0;

        $presetProducts = $this->presetProducts()->cursor();

        foreach($presetProducts as $presetProduct){
            if($presetProduct->product_id){
                if($presetProduct->option_type == TypeOption::REQUIRED)
                    $total += $presetProduct->product_price_origin + $presetProduct->option_price;

                if($presetProduct->option_type == TypeOption::ADDITIONAL)
                    $total += $presetProduct->option_price;
            }

            if($presetProduct->package_id){
                $materials = $presetProduct->materials;

                foreach($materials as $material){
                   $total += $material->pivot->price_origin;
                }
            }
        }

        return $total;
    }

    public function getPriceDiscountProductsAttribute()
    {
        return $this->price_origin_products - $this->price_products;
    }

    public function getPriceDeliveryAttribute()
    {
        $total = 0;

        $presets = $this->presets()->cursor();

        foreach($presets as $preset){
            $total += $preset->price_delivery;
        }

        return $total;
    }

    public function getPriceCouponAttribute()
    {
        return $this->presetProducts()->sum('price_coupon');
    }

    public function getFormatProductsAttribute()
    {
        $items = [];

        $presetProducts = $this->presetProducts;

        foreach($presetProducts as $presetProduct){
            if($presetProduct->option_type == TypeOption::REQUIRED){
                $items[] = $presetProduct->product_title." ({$presetProduct->option_title} * {$presetProduct->count})";
            }
        }

        return Arr::getArrayToString($items);
    }

    public function getFormatPayMethodAttribute()
    {
        // 가상계좌일 경우

        // 신용카드일 경우

        // 간편결제일 경우

        return $this->pay_method_name;
    }
}
