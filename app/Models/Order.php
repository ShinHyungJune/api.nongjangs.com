<?php

namespace App\Models;

use App\Enums\StateOrder;
use App\Enums\StatePresetProduct;
use App\Enums\TypeAlarm;
use App\Enums\TypeCouponHistory;
use App\Enums\TypePointHistory;
use App\Mail\PrototypeNeeded;
use Carbon\Carbon;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Support\Facades\DB;
use Illuminate\Support\Facades\Mail;

class Order extends Model
{
    use HasFactory;

    protected $guarded = ['id'];

    public static $minPrice = 1000;

    protected static function boot()
    {
        parent::boot(); // TODO: Change the autogenerated stub

        self::updating(function ($model){
            $prevState = $model->getOriginal('state');

            if($prevState != StateOrder::WAIT && $model->state == StateOrder::WAIT) {
                if(!$model->process_record)
                    $model->record();

                $model->process_record = true;
            }

            if($prevState != StateOrder::CANCEL && $model->state == StateOrder::CANCEL)
                $model->rollback();

            if($prevState != StateOrder::SUCCESS && $model->state == StateOrder::SUCCESS) {
                if($prevState != StateOrder::WAIT) {
                    if(!$model->process_record)
                        $model->record();

                    $model->process_record = true;
                }

                // $accessToken = Iamport::getAccessToken();
                // $model->check_receipt = Iamport::checkReceipt($accessToken, $model->imp_uid);

                $model->success();
                $model->process_success = true;

                Alarm::create([
                    'contact' => $model->buyer_contact,
                    'order_id' => $model->id,
                    'type' => TypeAlarm::ORDER_SUCCESS,
                ]);

                // 결제성공했을 때 시안 이미 작성한 애들은 시안제작필요 알림 보내기
                $presetProducts = $model->presetProducts()->where('additional', 0)->get();

                foreach($presetProducts as $presetProduct){
                    if($presetProduct->submit_request)
                        Alarm::create([
                            'contact' => env('ADMIN_CONTACT', '01092106861'),
                            'preset_product_id' => $presetProduct->id,
                            'type' => TypeAlarm::PRESET_PRODUCT_PROTOTYPE_REQUIRED,
                        ]);
                        // Mail::to(env('MAIL_ADMIN_ADDRESS', 'janginbiz@naver.com'))->send(new PrototypeNeeded($presetProduct));
                }
            }
        });

        self::updated(function ($model){
            $prevState = $model->getOriginal('state');

            if($prevState != StateOrder::WAIT && $model->state == StateOrder::WAIT) {
                if($model->pay_method_method == "vbank")
                    Alarm::create([
                        'contact' => $model->buyer_contact,
                        'order_id' => $model->id,
                        'type' => TypeAlarm::ORDER_CREATED_BY_VBANK,
                    ]);
            }

        });
    }

    // 포인트내역, 쿠폰내역 기록, 장바구니 삭제
    public function record()
    {
        if(!$this->process_record) {
            $user = User::withTrashed()->find($this->user_id);

            if ($user) {
                if($this->point_use){
                    $user->update(['point' => $user->point - $this->point_use]);

                    $user->pointHistories()->create([
                        'point_current' => $user->point,
                        'point' => $this->point_use,
                        'type' => TypePointHistory::ORDER_CREATED,
                        'increase' => 0,
                    ]);
                }

                $coupon = $this->coupon;

                if ($coupon) {
                    $user->couponHistories()->create([
                        'title' => $coupon->title,
                        'type' => TypeCouponHistory::ORDER_CREATED,
                        'increase' => 0,
                    ]);
                }
            }

            // 장바구니에서 삭제
            $this->presets()->update([
                'cart_id' => null,
            ]);
        }
    }

    // 포인트내역, 쿠폰내역 롤백
    public function rollback()
    {
        $user = User::withTrashed()->find($this->user_id);

        if($user) {
            if($this->point_use){
                $user->update(['point' => $user->point + $this->point_use]);

                $user->pointHistories()->create([
                    'point_current' => $user->point,
                    'point' => $this->point_use,
                    'type' => TypePointHistory::ORDER_CANCLED,
                    'increase'=>1,
                ]);
            }


            $coupon = $this->coupon;

            if($coupon){
                $user->couponHistories()->create([
                    'title' => $coupon->title,
                    'type' => TypeCouponHistory::ORDER_CANCLED,
                    'increase'=>1,
                ]);
            }
        }
    }

    // 상품준비중 처리
    public function success()
    {
        if(!$this->process_success){
            // 출고정리
            $this->presetProducts()->update([
                'state' => StatePresetProduct::READY,
            ]);

            $presets = $this->presets()->cursor();

            foreach($presets as $preset){
                $products = $preset->products()->cursor();

                foreach($products as $product){
                    $product->update(['count_order' => $product->count_order + 1]);
                    $product->update(['real_count_order' => $product->real_count_order + 1]);
                }
            }
        }

    }

    public function getFormatStateAttribute()
    {
        return StateOrder::getLabel($this->state);
    }

    public function ready($presetItems, $user = null, $guestId = null)
    {
        $presets = collect();

        foreach($presetItems as $presetItem){
            $preset = Preset::find($presetItem['id']);

            if($user && $preset->user_id != $user->id)
                return [
                    'success' => false,
                    'message' => '자신의 상품만 구매할 수 있습니다'
                ];

            if(!$user && $preset->guest_id != $guestId)
                return [
                    'success' => false,
                    'message' => '자신의 상품만 구매할 수 있습니다'
                ];

            if(!$preset->can_order)
                return [
                    'success' => false,
                    'message' => '구매할 수 없는 상품이 포함되어있습니다.'
                ];

            $presets->add($preset);
        }

        $order = Order::create([
            'user_id' => $user ? $user->id : null,
            'user_contact' => $user ? $user->contact : "",
            'user_email' => $user ? $user->email : "",
            'user_name' => $user ? $user->name : "",
            'guest_id' => $guestId,

            'state' => StateOrder::BEFORE_PAYMENT,
        ]);

        foreach($presets as $preset){
            $preset->update([
                'order_id' => $order->id,
            ]);
        }

        return [
            'success' => true,
            'data' => $order
        ];
    }

    // 맞춤결제여부
    public function isCustomOrder()
    {
        $countTotal = $this->presetProducts()->whereHas('product', function ($query){
            $query->whereNull('product_id'); // 추가상품은 제외
        })->count();

        $countCustom = $this->presetProducts()->whereHas('product', function ($query){
            $query->whereNull('product_id') // 추가상품은 제외
                ->where('custom', 1);
        })->count();

        if($countCustom > 0 && $countCustom == $countTotal)
            return true;

        return false;
    }

    public function attempt($data, $guestId = null)
    {
        $presets = $this->presets;

        $priceDelivery = 0;
        $priceCouponDiscount = 0;
        $priceProducts = 0;
        $point = $data['point_use'];

        $coupon = null;

        if($point > 0 && auth()->user()->point < $point)
            return [
                'success' => false,
                'message' => '보유 포인트가 부족합니다.'
            ];

        if(auth()->user() && isset($data['coupon_id']))
            $coupon = auth()->user()->validCoupons()->where('id', $data['coupon_id'])->first();

        foreach($presets as $preset){

            if(!$preset->can_order)
                return [
                    'success' => false,
                    'message' => '주문할 수 없습니다. 관리자에게 문의해주세요.'
                ];

            $products = $preset->products()->wherePivot('additional', 0)->get();
            $additionalProducts = $preset->products()->wherePivot('additional', 1)->get();

            $preset->presetProducts()->update([
                /*'buyer_name' => $data['buyer_name'],
                'buyer_email' => $data['buyer_email'],
                'buyer_contact' => $data['buyer_contact'],
                'buyer_address' => $data['buyer_address'],
                'buyer_address_detail' =>$data['buyer_address_detail'],
                'buyer_address_zipcode' => $data['buyer_address_zipcode'],*/
                'delivery_name' => $data['delivery_name'],
                'delivery_contact' => $data['delivery_contact'],
                'delivery_address' => $data['delivery_address'],
                'delivery_address_detail' => $data['delivery_address_detail'],
                'delivery_address_zipcode' => $data['delivery_address_zipcode'],
                'delivery_requirement' => isset($data['delivery_requirement']) ? $data['delivery_requirement'] : null,
                'type_delivery' => $data['type_delivery'],
            ]);

            foreach($products as $product){
                $priceProducts += ($product->pivot->price + $product->pivot->size_price) * $product->pivot->count;
            }

            // 첫번째 product의 배송비 (이건 다른거 개발할때는 고민해봐야됨)
            $priceDelivery = $products->first()->price_delivery;

            foreach($additionalProducts as $additionalProduct){
                $priceProducts += $additionalProduct->pivot->price * $additionalProduct->pivot->count;
            }
        }

        if($coupon)
            $priceCouponDiscount = floor(($priceProducts + $priceDelivery - $point) / 100 * $coupon->ratio_discount);

        $price = $priceProducts + $priceDelivery - $priceCouponDiscount - $point;

        if($price < self::$minPrice)
            return [
                'success' => false,
                'message' => '최소결제금액은 1,000원입니다.'
            ];

        $payMethod = PayMethod::find($data['pay_method_id']);

        if(auth()->user()){
            if($data['need_tax']){
                auth()->user()->update([
                    'tax_business_number' => $data['tax_business_number'],
                    'tax_company_title' => $data['tax_company_title'],
                    'tax_company_president' => $data['tax_company_president'],
                    'tax_company_type' => $data['tax_company_type'],
                    'tax_company_category' => $data['tax_company_category'],
                    'tax_email' => $data['tax_email'],
                    'tax_name' => $data['tax_name'],
                    'tax_contact' => $data['tax_contact'],
                    'tax_address' => $data['tax_address'],
                ]);
            }

            if($data['buyer_address'] && !auth()->user()->address){
                auth()->user()->update([
                    'address' => $data['buyer_address'],
                    'address_detail' => $data['buyer_address_detail'],
                    'address_zipcode' => $data['buyer_address_zipcode'],
                ]);
            }
        }


        $this->update([
            'need_tax' => $data['need_tax'],
            'tax_business_number' => $data['tax_business_number'],
            'tax_company_title' => $data['tax_company_title'],
            'tax_company_president' => $data['tax_company_president'],
            'tax_company_type' => $data['tax_company_type'],
            'tax_company_category' => $data['tax_company_category'],
            'tax_email' => $data['tax_email'],
            'tax_name' => $data['tax_name'],
            'tax_contact' => $data['tax_contact'],
            'tax_address' => $data['tax_address'],

            'price' => $price,
            'price_products' => $priceProducts,
            'price_delivery' => $priceDelivery,
            'point_use' => $point,
            'price_coupon_discount' => $priceCouponDiscount,

            'merchant_uid' => 'ORD-' . $this->id.Carbon::now()->format('Hisv'),
            'pay_method_id' => $payMethod->id,
            'pay_method_pg' => $payMethod->pg,
            'pay_method_method' => $payMethod->method,
            'pay_method_name' => $payMethod->name,
            'pay_method_commission' => $payMethod->commission,

            'buyer_name' => $data['buyer_name'],
            'buyer_email' => $data['buyer_email'],
            'buyer_contact' => $data['buyer_contact'],
            'buyer_address' => $data['buyer_address'],
            'buyer_address_detail' =>$data['buyer_address_detail'],
            'buyer_address_zipcode' => $data['buyer_address_zipcode'],

            'delivery_name' => $data['delivery_name'],
            'delivery_contact' => $data['delivery_contact'],
            'delivery_address' => $data['delivery_address'],
            'delivery_address_detail' => $data['delivery_address_detail'],
            'delivery_address_zipcode' => $data['delivery_address_zipcode'],
            'delivery_requirement' => isset($data['delivery_requirement']) ? $data['delivery_requirement'] : null,
            'type_delivery' => $data['type_delivery'],
            'agree_open' => isset($data['agree_open']) ? $data['agree_open'] : 0,
        ]);

        if($coupon)
            $coupon->update(['order_id' => $this->id]);

        return [
            'success' => true,
        ];
    }

    public function presets()
    {
        return $this->hasMany(Preset::class);
    }

    public function presetProducts()
    {
        return $this->hasManyThrough(PresetProduct::class, Preset::class);
    }

    public function checkCanOrderSaleProduct($saleProduct, $count)
    {
        if(!$saleProduct)
            return [
                'success' => false,
                'message' => '존재하지 않는 상품이 포함되어있습니다.'
            ];

        if($saleProduct->count < $count)
            return [
                'success' => false,
                'message' => '재고가 부족합니다.'
            ];

        /*if(!$saleProduct->open)
            return [
                'success' => false,
                'message' => '비공개 상품이 포함되어있습니다.'
            ];*/

        return [
            'success' => true,
        ];
    }

    public function getCanCancelAttribute()
    {
        if(!auth()->user())
            return 0;

        if(auth()->user()->id != $this->user_id)
            return 0;

        if($this->pay_method_method == "vbank")
            return 0;

        if($this->presetProducts()->whereIn('state', [
                StatePresetProduct::FINISH_PROTOTYPE,
                StatePresetProduct::ONGOING_DELIVERY,
                StatePresetProduct::DELIVERED,
                StatePresetProduct::CONFIRMED,
                StatePresetProduct::CANCEL,
                StatePresetProduct::ONGOING_REFUND,
                StatePresetProduct::FINISH_REFUND,
                StatePresetProduct::DENY_REFUND,])->count() > 0) {
            return 0;
        }

        return 1;
    }

    public function getAdminCanCancelAttribute()
    {
        if(!auth()->user() || !auth()->user()->admin)
            return 0;

        if($this->pay_method_method == "vbank")
            return 0;

        if($this->presetProducts()->whereIn('state', [
                StatePresetProduct::CONFIRMED,
                StatePresetProduct::CANCEL
            ])->count() > 0) {
            return 0;
        }

        return 1;
    }

    public function cancel()
    {
        $result = DB::transaction(function (){
            if(config('app.env') != 'testing'){
                $accessToken = Iamport::getAccessToken();

                $result = Iamport::cancel($accessToken, $this->imp_uid);

                if(!$result["response"])
                    return ["success" => false, "message" => $result["message"]];
            }

            $this->update(["state" => StateOrder::CANCEL]);

            $this->presetProducts()->update(["preset_product.state" => StatePresetProduct::CANCEL]);

            return ["success" => true, "message" => "주문이 취소되었습니다."];
        });

        return $result;
    }

    public function coupon()
    {
        return $this->hasOne(Coupon::class);
    }

    public function getPriceProductsDiscountAttribute()
    {
        return $this->presetProducts()->where('additional', 0)->sum('price_discount');
    }

    public function getFormatProducts($presetProducts)
    {
        $items = [];

        foreach($presetProducts as $presetProduct){
            $items[] = $presetProduct->additional
                ? "{$presetProduct->product_title} (추가상품)"
                : "{$presetProduct->product_title} ({$presetProduct->color_title} * {$presetProduct->size_title})";
        }

        return Arr::getArrayToString($items);
    }

    public function getPresentPresetProductAttribute()
    {
        return $this->presetProducts()->where('additional', 0)->orderBy('id', 'asc')->first();
    }
}
