<?php


use App\Models\Count;
use App\Models\User;
use Illuminate\Foundation\Testing\RefreshDatabase;
use Illuminate\Foundation\Testing\WithFaker;
use Tests\TestCase;

class PresetsTest extends TestCase
{
    use RefreshDatabase;

    protected $user;

    protected $other;

    protected $form;

    protected function setUp(): void
    {
        parent::setUp(); // TODO: Change the autogenerated stub

        $this->user = User::factory()->create();
        $this->other = User::factory()->create();

        $this->actingAs($this->user);

        $this->form = [

        ];
    }

    /** @test */
    public function 사용자는_데이터를_생성할_수_있다()
    {
        /*[
            {
                product_id: "",
                option_id: "",
                count: "",
            }
        ]*/
    }

    /** @test */
    public function 재고보다_더_많이_생성할_수_없다()
    {
        // 반복문으로 옵션과 상품의 재고를 확인하고 forBidden으로 무슨 상품 재고가 털렸는지 뿌려주기
    }

    /** @test */
    public function 데이터를_생성하면_비용이_갱신된다()
    {
/*# calculate
        - price 최총 금액
    - price_total 상품 총 금액
    - price_discount 할인금액
    - price_delivery 배송비
    - count_option_required
    - count_option_additional

# 배송비 계산
    - type_delivery가 FREE라면
    - price_delivery = 0
        - type_delivery가 EACH라면
    - type_delivery_price가 STATIC이라면
    - price_delivery = price_delivery
        - type_delivery가 CONDITIONAL이라면
    - min_price_for_free_delivery_price <= price?
        - 참이라면 무료
        - 거짓이라면 price_delivery
    - type_delivery가 PRICE_BY_COUNT라면
    -  prices_delivery 배열을 순차조회하면서 상품조합의 필수옵션 선택한 상품의 개수가 n개 이상인 구간 찾기 (그 구간의 price가 배송비)
	-> 도서산간이면 delivery_price_far_place 추가해야함

# 쿠폰
최종가 기준으로 쿠폰 적용되어야함*/
    }
    /** @test */
    public function 사용자는_자신의_데이터를_수정할_수_있다()
    {
        /*[
            {
                product_id: "",
                option_id: "",
                count: "",
            }
        ]*/
    }
    /** @test */
    public function 데이터를_수정하면_비용이_갱신된다()
    {

    }


}
